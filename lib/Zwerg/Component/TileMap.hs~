module Zwerg.Component.TileMap (
    TileMap,
    mkTileMap,
    tileUUIDatPosition
    ) where

import Zwerg.Prelude
import Zwerg.Const
import Zwerg.Util
import Zwerg.Component.UUID
import Zwerg.Component.Position
import Zwerg.Data.Error
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as M

import Data.Binary
import GHC.Generics (Generic)

newtype TileMap = MkTileMap (Map Position UUID)
    deriving (Eq, Show, Generic)

instance Wrapped TileMap (Map Position UUID) where
    unwrap (MkTileMap tm) = tm

instance Binary TileMap

{-# INLINABLE mkTileMap #-}
mkTileMap :: (MonadError ZError m)
         => [(Position,UUID)] -> m TileMap
mkTileMap tl = if (length tl /= (round $ mapWidth * mapHeight))
  then throwError $ ZError Fatal __FILE__ __LINE__ (map snd tl)
       "Attempted to construct a TileMap with number of tiles \
       not equal to mapWidth * mapHeight"
  else return . MkTileMap $ M.fromList tl

{-# INLINABLE tileUUIDatPosition #-}
tileUUIDatPosition :: (MonadError ZError m)
                   => Position
                   -> TileMap
                   -> m UUID
tileUUIDatPosition pos (MkTileMap tm) =
  let maybeUUID = M.lookup pos tm
  in fromJustErrM maybeUUID $
       ZError Fatal __FILE__ __LINE__ []
       "Attempted to find tile UUID at non-existent position"

  
  
